import { QWrapperDomain } from 'q-wrapper';
import { QWrapperSettings } from 'q-wrapper/lib/models';
import { Message as amqMessage } from 'amqplib/callback_api';
import * as operationIds from './operationIds';
import * as domains from './domainIndex';
import eventBus from '@/utils/eventBus';

{% set asyncApiIncOpIds = nodegenRc.asyncApi.includedOperationIds -%}
{% set asyncApiExcOpIds = nodegenRc.asyncApi.excludedOperationIds -%}
class RabbitMQService {
  private qWrapper: QWrapperDomain;

  public async setup (qWrapperSettings: QWrapperSettings): Promise<void> {
    this.qWrapper = new QWrapperDomain(qWrapperSettings);
    await this.qWrapper.initialize();
    this.listenForInternalAppEvents();
    this.listenForRabbitMQ();
  }

  public listenForInternalAppEvents () {
    {% for channelName, channelObj in swagger.channels -%}{% if channelObj.publish -%}
    {% set channelId = _.toUpper(channelObj.publish.operationId) -%}
    eventBus.on(operationIds.{{ channelId }}, (payload: any) => {
      console.log('EVENT ' + operationIds.{{ channelId }});
      this.qWrapper.sendToExchange(
        payload,
        operationIds.{{ channelId }});
    });
    {% endif -%}
    {% endfor -%}
  }

  public listenForRabbitMQ (): void {
    this.qWrapper.consume(async (message: amqMessage) => {
      switch (message.fields.routingKey) {
        {% for channelName, channelObj in swagger.channels -%}
        {% if channelObj.subscribe -%}
        {% set opId = channelObj.subscribe.operationId -%}
        {% if (not asyncApiIncOpIds and not asyncApiExcOpIds)
          or (asyncApiIncOpIds and _.indexOf(asyncApiIncOpIds, opId) == -1)
          or (asyncApiExcOpIds and _.indexOf(asyncApiExcOpIds, opId) != -1) -%}
        {% set channelId = _.toUpper(channelObj.subscribe.operationId) -%}
        case operationIds.{{ channelId }}: {
          // Start doing something with the message...
          // Return a response
          {% set domainName = ucFirst([_.camelCase(opId), 'Domain'] | join) -%}
          let processed = true;
          let requeue = true;
          try {
            await domains.{{ domainName }}(message.content.toString());
          } catch (e) {
            console.error(e);
            processed = false;
            requeue = true;
          }
          return {
            processed,
            requeue
          };
        }
        {% endif -%}
        {% endif -%}
        {% endfor -%}
        default:
          return {
            processed: true,
            requeue: false
          };
      }
    });
  }
}

export default new RabbitMQService();
